# MPOCryptoML 전체 로직 설명

## 🎯 최종 목표

**이상 거래 탐지**: 블록체인 거래 그래프에서 사기 지갑(anomaly)을 찾기

---

## 📋 전체 파이프라인 (6단계)

### **Step 1: 그래프 구성 G=(V, E, W, T)**

**목적**: 실제 거래 데이터를 그래프로 변환

```python
G = (V, E, W, T)
```

- **V (Vertices)**: 지갑 주소들 (노드)
  - 예: 0x73f8fc2e74302eb2efda125a326655acf0dc2d1b
- **E (Edges)**: 거래 관계
  - 예: (Alice → Bob)
- **W (Weights)**: 거래 금액 (ETH)
  - 예: 15.73 ETH
- **T (Timestamps)**: 거래 발생 시간
  - 예: 1633024800 (Unix timestamp)

**우리의 데이터**:

- 7,692개 노드
- 26,678개 엣지 (거래)
- 200개 사기 지갑 (라벨)

---

### **Step 2: PPR (Personalized PageRank)**

**목적**: "중요한 노드" 찾기 (네트워크 영향력)

**PPR이란?**

- 일반 PageRank: "전체 네트워크에서 인기 있는 페이지"
- Personalized PageRank: "특정 노드에서 시작했을 때, 어떤 노드들이 영향받는가?"

```python
π(s, v) = Σ PPR 점수
```

**알고리즘**:

1. Source node들 선택 (in-degree=0, 즉 "최상위 시작점")
2. 각 source에서 PPR 계산
3. 모든 source의 PPR을 합산 → π(vi)

**왜 필요한가?**

- 사기 지갑은 보통 "중간자" 역할을 많이 함
- 많은 노드들이 영향받으면 → PPR 높음
- 사기 가능성 증가

**우리의 설정**:

- 10개 source nodes
- alpha = 0.5 (점프 확률)
- ε = 0.01 (수렴 기준)

---

### **Step 3: NTS (Normalized Timestamp Score)**

**목적**: "시간 패턴 이상성" 측정

**계산 방식**:

```python
# 입금 시간 범위
θ_in(vi) = max(입금 timestamp) - min(입금 timestamp)

# 송금 시간 범위
θ_out(vi) = max(송금 timestamp) - min(송금 timestamp)

# 차이 계산
θ(vi) = |θ_out(vi) - θ_in(vi)|

# 정규화 (0~1)
NTS(vi) = (θ(vi) - min_θ) / (max_θ - min_θ)
```

**의미**:

- 입금과 송금의 시간 분포가 다르면 → θ(vi) 높음
- 사기 지갑은 "빠른 입출금" 패턴 → NTS 높음

**예시**:

```python
정상 지갑:
  입금: 10:00, 10:05, 10:10 (5분 간격)
  송금: 10:15, 10:20 (10분 간격)
  θ_in = 10분, θ_out = 5분
  θ = |10 - 5| = 5분

사기 지갑 (빠른 회전):
  입금: 10:00, 10:01, 10:02 (1분 간격)
  송금: 10:05 (1회)
  θ_in = 2분, θ_out = 0분
  θ = |0 - 2| = 2분

NTS = θ가 클수록 높은 점수
```

---

### **Step 4: NWS (Normalized Weight Score)**

**목적**: "금액 패턴 이상성" 측정

**계산 방식**:

```python
# 입금 총액
ω_in(vi) = Σ 입금 금액

# 송금 총액
ω_out(vi) = Σ 송금 금액

# 차이 계산
ω(vi) = |ω_out(vi) - ω_in(vi)|

# 정규화 (0~1)
NWS(vi) = (ω(vi) - min_ω) / (max_ω - min_ω)
```

**의미**:

- 입금과 송금 금액이 일치하지 않으면 → ω(vi) 높음
- 사기 지갑은 "불일치" 패턴 (돈 쌓아두기, 빠른 이동)

**예시**:

```python
정상 지갑:
  입금: 10 ETH
  송금: 10 ETH
  ω = |10 - 10| = 0

사기 지갑:
  입금: 10 ETH, 5 ETH, 3 ETH (총 18 ETH)
  송금: 100 ETH
  ω = |100 - 18| = 82 ETH

NWS = ω가 클수록 높은 점수
```

---

### **Step 5: Logistic Regression (패턴 점수)**

**목적**: NTS, NWS → "사기일 확률" 변환

**문제**:

- NTS, NWS만으로는 판단이 어려움
- 어떤 조합이 사기인가?

**해결**: Logistic Regression

```python
입력: [NTS, NWS] (2차원)
출력: F(θ,ω)(vi) = "사기일 확률" (0~1)
```

**학습**:

```python
Train data: 6,153개
Test data: 1,539개

X = [[nts1, nws1], [nts2, nws2], ...]
y = [0, 1, 0, 1, ...]  # 라벨
```

**결과**:

- Accuracy: 0.9812
- **하지만**: Precision = 0.0, Recall = 0.0
- **원인**: 클래스 불균형 (사기 2.58%, 정상 97.42%)

**해결책**: `class_weight='balanced'` 추가

---

### **Step 6: Anomaly Score (최종 탐지)**

**목적**: "이상 거래 점수" 계산

**공식**:

```python
σ(vi) = π(vi) / F(θ,ω)(vi)
```

**의미**:

- **π(vi)**: PPR 합계 (네트워크 영향력, 높을수록 좋음)
- **F(vi)**: 패턴 점수 (사기 확률, 낮을수록 이상)
- **σ(vi)**: 최종 점수 (높을수록 이상 거래)

**해석**:

- PPR 높고 + 패턴 점수 낮으면 → 사기 가능성 ↑
- 예: σ(vi) = 258.6 → Top 3으로 랭크

**최종 추천**:

- Top K 개 지갑 추천
- K=20 시, 200개 중 1~2개 탐지

---

## 📊 최종 평가 지표

### Precision@K

```python
Precision@K = 탐지된 사기 개수 / K
```

예: K=20, 1개 탐지 → Precision@20 = 0.05

### Recall@K

```python
Recall@K = 탐지된 사기 개수 / 전체 사기 개수
```

예: 1개 탐지 / 200개 → Recall@20 = 0.005

---

## 🔧 현재 문제점과 해결책

### 1. 클래스 불균형

- **문제**: 사기 200개 vs 정상 7,554개
- **해결**: `class_weight='balanced'` ✅ (완료)

### 2. 특징 부족

- **문제**: NTS, NWS만으로는 부족
- **해결**:
  - 패턴 특징 추가 (Layering, Fan-in, Fan-out)
  - 노드 중심성 지표
  - 거래 시간 분포

### 3. PPR 파라미터

- **문제**: alpha=0.5가 적절한가?
- **해결**: Grid search 필요

### 4. 성능 향상

- **목표**: Precision@20 ≥ 50%
- **현재**: 5%

---

## 💡 핵심 아이디어

**논문의 혁신점**:

1. **PPR 활용**: 네트워크 구조 정보 활용
2. **특징 조합**: NTS (시간) + NWS (금액)
3. **Anomaly Score**: σ(vi) = 네트워크 영향력 / 사기 패턴

**우리가 한 것**:

- ✅ Etherscan 실제 데이터 수집
- ✅ Timestamp 매칭
- ✅ 전체 파이프라인 구현
- ✅ 클래스 불균형 해결 중

**다음 단계**:

- 🔄 하이퍼파라미터 튜닝
- 🔄 특징 확장
- 🔄 성능 개선
